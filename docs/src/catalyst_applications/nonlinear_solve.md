# [Finding Steady States using NonlinearSolve.jl](@id nonlinear_solve)

We have previously described how `ReactionSystem` steady states can be found through [homotopy continuation](@ref homotopy_continuation). Catalyst also supports the creation of `NonlinearProblems` corresponding to `ODEProblems` with all left-hand side derivatives set to 0. These can be solved using the variety of nonlinear equation-solving algorithms implemented by [NonlinearSolve.jl](https://github.com/SciML/NonlinearSolve.jl), with the solutions corresponding to system steady states. Generally, using this approach is advantageous when:
- Only a single steady state solution is sought.
- The nonlinear system produced by the model does not correspond to a multivariate, rational, polynomial (homotopy continuation cannot be applied to these systems). Examples include models with non-integer hill coefficients or stoichiometric constants.

However, if all (or multiple) steady states are sought, using homotopy continuation is better.

This tutorial describes how to create `NonlinearProblem`s from Catalyst's `ReactionSystemn`s, and how to solve them using NonlinearSolve. More extensive descriptions of available solvers and options can be found in [NonlinearSolve's documentation](https://docs.sciml.ai/NonlinearSolve/stable/).

## Basic example
Let us consider a simple dimerisation network, where a protein ($P$) can exist in a monomer and a dimer form. The protein is produced at a constant rate from its mRNA, which is also produced at a constant rate.
```@example nonlinear_solve1
using Catalyst
dimer_production = @reaction_network begin
    pₘ, 0 --> mRNA
    pₚ, mRNA --> mRNA + P
    (k₁, k₂), 2P <--> P₂
    d, (mRNA, P, P₂) --> 0
end
```
This system corresponds to the following ODE:
```math
\begin{aligned}
\frac{dmRNA}{dt} &= pₘ - d \cdot mRNA \\
\frac{dP}{dt} &= pₚ \cdot mRNA - k₁ \cdot P + 2k₂ \cdot P₂ - d \cdot P \\
\frac{dP₂}{dt} &= k₁ \cdot P + 2k₂ \cdot P₂ \\
\end{aligned}
```
To find its steady states we need to solve:
```math
\begin{aligned}
0 &= pₘ - d \cdot mRNA \\
0 &= pₚ \cdot mRNA - k₁ \cdot P + 2k₂ \cdot P₂ - d \cdot P \\
0 &= k₁ \cdot P + 2k₂ \cdot P₂ \\
\end{aligned}
```

To solve this problem, we must first designate our parameter values, and also make an initial guess of the solution. Generally, for problems with a single solution (like this one), most arbitrary guesses will work fine (the exception typically being [systems with conservation laws](@ref nonlinear_solve_conservation_laws)). Using these, we can create the `NonlinearProblem` that we wish to solve.
```@example nonlinear_solve1
p = [:pₘ => 0.5, :pₚ => 2.0, :k₁ => 5.0, :k₂ => 1.0, :d => 1.0]
u_guess = [:mRNA => 1.0, :P => 1.0, :P₂ => 1.0]
nl_prob = NonlinearProblem(dimer_production, u_guess, p)
```
Finally, we can solve it using the `solve` command, returning the steady state solution:
```@example nonlinear_solve1
using NonlinearSolve
sol = solve(nl_prob)
```

NonlinearSolve provides [a wide range of potential solvers](https://docs.sciml.ai/NonlinearSolve/stable/solvers/NonlinearSystemSolvers/). If we wish to designate one, it can be supplied as a second argument to `solve`. Here, we use the Newton Trust Region method, and then check that the solution is equal to the previous one.
```@example nonlinear_solve1
sol_ntr = solve(nl_prob, TrustRegion())
sol ≈ sol_ntr
```

## [Finding steady states through ODE simulations](@id nonlinear_solve_ode_simulation_based)
The `NonlinearProblem`s generated by Catalyst corresponds to ODEs. A common method of solving these is to simulate the ODE from an initial condition until a steady state is reached. NonlinearSolve supports this through the `DynamicSS` method. To use it, an appropriate ODE solver (and any options you wish it to use) must also be supplied (with [a large number being available](https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/)). Here, we will use the `Tsit5` ODE solver to find the steady states of our dimerisation system.
```@example nonlinear_solve1
using OrdinaryDiffEq, SteadyStateDiffEq
solve(nl_prob, DynamicSS(Tsit5()))
```
Here, we had to import [OrdinaryDiffEq.jl](https://github.com/SciML/OrdinaryDiffEq.jl) (to use `Tsit5`) and [SteadyStateDiffEq.jl](https://github.com/SciML/SteadyStateDiffEq.jl) (to use `DynamicSS`).

Like previously, the found steady state is unaffected by the initial `u` guess. However, when [finding the steady states of systems with conservation laws](@ref nonlinear_solve_conservation_laws) it is important to select a `u` guess that corresponds to the initial condition for the ODE model for which a steady state is sought.


## [Systems with conservation laws](@id nonlinear_solve_conservation_laws)
As described in the section on homotopy continuation, when finding the steady states of systems with conservation laws, [additional considerations have to be taken](homotopy_continuation_conservation_laws). E.g. consider the following two-state system:
```@example nonlinear_solve2
using Catalyst, NonlinearSolve # hide
two_state_model = @reaction_network begin
    (k1,k2), X1 <--> X2
end
```
It has an infinite number of steady states. To make steady state finding possible, information of the system's conserved quantities (here $C=X1+X2$) must be provided. Since these can be computed from system initial conditions (`u0`, i.e. those provided when performing ODE simulations), designating an `u0` is often the best way. There are two ways to do this. First, one can perform [ODE simulation-based steady state finding](@ref nonlinear_solve_ode_simulation_based), using the initial condition as the initial `u` guess. Alternatively, any conserved quantities can be eliminated when the `NonlinearProblem` is created. This feature is supported by Catalyst's [conservation law finding and elimination feature](@ref network_analysis_deficiency).

To eliminate conservation laws we simply provide the `remove_conserved = true` argument to `NonlinearProblem`:
```@example nonlinear_solve2
p = [:k1 => 2.0, :k2 => 3.0]
u_guess = [:X1 => 3.0, :X2 => 1.0]
nl_prob = NonlinearProblem(two_state_model, u_guess, p; remove_conserved = true)
nothing # hide
```
here it is important that the quantities used in `u_guess` correspond to the conserved quantities we wish to use. E.g. here the conserved quantity $X1 + X2= 3.0 + 1.0 = 4$ holds for the initial condition, and will hence also hold in the calculated steady-state as well. We can now find the steady states using `solve` like before:
```@example nonlinear_solve2
sol = solve(nl_prob)
```
We note that the output only provides a single value. The reason is that the actual system solved only contains a single equation (the other being eliminated with the conserved quantity). To find the values of $X1$ and $X2$ we can [directly query the solution object for these species' values, using the species themselves as inputs](@ref simulation_structure_interfacing_solutions):
```@example nonlinear_solve2
@unpack X1, X2 = two_state_model
sol[X1]
```
```@example nonlinear_solve2
sol[X2]
```

---
## [Citations](@id nonlinear_solve_citation)
If you use this functionality in your research, [in addition to Catalyst](@ref catalyst_citation), please cite the following papers to support the authors of the NonlinearSolve.jl package:
```
A NonlinearSolve. jl-related publication is in preparation, once it is available, its details will be added here.
```
